from typing import Any, overload
from typing_extensions import Self

def version() -> str: ...

class Allocator:
    def __init__(self, *, unlocked: bool = False) -> None: ...
    def __del__(self) -> None: ...
    def fast_malloc(self, size: int) -> int: ...
    def fast_free(self, ptr: int) -> None: ...

class Option:
    num_threads: int
    use_local_pool_allocator: bool
    use_vulkan_compute: bool

    def __init__(self) -> None: ...
    def __del__(self) -> None: ...
    def set_blob_allocator(self, allocator: Allocator) -> None: ...
    def set_workspace_allocator(self, allocator: Allocator) -> None: ...

class Mat:
    def __init__(self, w: int = 0, h: int = 0, d: int = 0, c: int = 0, *, data: Any | None = None, elemsize: int = 0, elempack: int = 0, allocator: Allocator | None = None) -> None: ...
    def __del__(self) -> None: ...
    def fill(self, value: float) -> None: ...
    def clone(self, allocator: Allocator | None = None) -> Self: ...
    def reshape(self, *args: Any) -> Self: ...
    def flatten(self, opt: Option) -> Self: ...
    def convert_packing(self, elempack: int, opt: Option) -> Self: ...

    @property
    def dims(self) -> int: ...
    @property
    def w(self) -> int: ...
    @property
    def h(self) -> int: ...
    @property
    def d(self) -> int: ...
    @property
    def c(self) -> int: ...
    @property
    def elemsize(self) -> int: ...
    @property
    def elempack(self) -> int: ...
    @property
    def cstep(self) -> int: ...
    @property
    def data(self) -> int: ...

    def get_channel_data(self, c: int) -> int: ...

    @classmethod
    def from_pixels(cls, pixels: Any, type: int, w: int, h: int, stride: int, allocator: Allocator | None = None) -> Self: ...
    @classmethod
    def from_pixels_resize(cls, pixels: Any, type: int, w: int, h: int, stride: int, target_width: int, target_height: int, allocator: Allocator | None = None) -> Self: ...
    @classmethod
    def from_pixels_roi(cls, pixels: Any, type: int, w: int, h: int, stride: int, roix: int, roiy: int, roiw: int, roih: int, allocator: Allocator | None = None) -> Self: ...
    @classmethod
    def from_pixels_roi_resize(cls, pixels: Any, type: int, w: int, h: int, stride: int, roix: int, roiy: int, roiw: int, roih: int, target_width: int, target_height: int, allocator: Allocator | None = None) -> Self: ...

    def to_pixels(self, pixels: Any, type: int, stride: int) -> None: ...
    def to_pixels_resize(self, pixels: Any, type: int, target_width: int, target_height: int, target_stride: int) -> None: ...
    def substract_mean_normalize(self, mean_vals: Any | None, norm_vals: Any | None) -> None: ...
    def to_bytes(self) -> bytes: ...
    def copy_make_border(self, top: int, bottom: int, left: int, right: int, type: int, v: float, opt: Option, *, front: int = -1, behind: int = -1) -> Self: ...
    def copy_cut_border(self, top: int, bottom: int, left: int, right: int, opt: Option, *, front: int = -1, behind: int = -1) -> Self: ...
    def draw_rectangle(self, rect: tuple[int, int, int, int], color: int, thickness: int) -> None: ...
    def draw_text(self, text: str, origin: tuple[int, int], font_size: int, color: int) -> None: ...
    def draw_circle(self, center: tuple[int, int], radius: int, color: int, thickness: int) -> None: ...
    def draw_line(self, pt1: tuple[int, int], pt2: tuple[int, int], color: int, thickness: int) -> None: ...

class Blob:
    @property
    def name(self) -> str: ...
    @property
    def producer(self) -> int: ...
    @property
    def consumer(self) -> int: ...
    @property
    def shape(self) -> tuple[int, int, int, int]:  ...

class ParamDict:
    def __init__(self) -> None: ...
    def __del__(self) -> None: ...
    def get_type(self, id: int) -> int: ...
    def get_int(self, id: int, default: int) -> int: ...
    def get_float(self, id: int, default: float) -> float: ...
    def get_array(self, id: int, default: Mat) -> Mat | None: ...
    def set_int(self, id: int, i: int) -> None: ...
    def set_float(self, id: int, f: float) -> None: ...
    def set_array(self, id: int, v: Mat) -> None: ...

class DataReader:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, *, from_memory: Any) -> None: ...
    @overload
    def __init__(self, *, from_stdio: int) -> None: ...

    def __del__(self) -> None: ...
    def scan(self, format: str, data: Any) -> int: ...
    def read(self, buffer: Any) -> int: ...

class ModelBin:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, *, from_datareader: DataReader) -> None: ...
    @overload
    def __init__(self, *, from_mat_array: list[Mat]) -> None: ...

    def __del__(self) -> None: ...
    def load(self, *args: int) -> Mat | None: ...

class Layer:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, *, type: str) -> None: ...
    @overload
    def __init__(self, *, typeindex: int) -> None: ...

    def __del__(self) -> None: ...

    one_blob_only: bool
    support_inplace: bool
    support_vulkan: bool
    support_packing: bool
    support_bf16_storage: bool
    support_fp16_storage: bool

    @property
    def name(self) -> str: ...
    @property
    def typeindex(self) -> int: ...
    @property
    def type(self) -> str: ...
    @property
    def bottom_count(self) -> int: ...
    @property
    def top_count(self) -> int: ...
    
    @staticmethod
    def type_to_index(type: str) -> int: ...
    
    def get_bottom(self, i: int) -> int: ...
    def get_top(self, i: int) -> int: ...
    def get_bottom_shape(self, i: int) -> tuple[int, int, int, int]: ...
    def get_top_shape(self, i: int) -> tuple[int, int, int, int]: ...
    def load_param(self, pd: ParamDict) -> int: ...
    def load_model(self, mb: ModelBin) -> int: ...
    def create_pipeline(self, opt: Option) -> int: ...
    def destroy_pipeline(self, opt: Option) -> int: ...

    @overload
    def forward(self, bottom_blob: Mat, opt: Option) -> Mat: ...
    @overload
    def forward(self, bottom_blobs: list[Mat], top_blobs_count: int, opt: Option) -> tuple[Mat, ...]: ...
    def forward(self, *args, **kwargs): ...

    @overload
    def forward_inplace(self, bottom_top_blob: Mat, opt: Option) -> int: ...
    @overload
    def forward_inplace(self, bottom_top_blobs: list[Mat], opt: Option) -> int: ...
    def forward_inplace(self, *args, **kwargs): ...

class Net:
    option: Option

    @property
    def input_count(self) -> int: ...
    @property
    def output_count(self) -> int: ...

    def __init__(self) -> None: ...
    def __del__(self) -> None: ...
    def set_vulkan_device(self, device_index: int) -> None: ...

    @overload
    def register_custom_layer(self, type: str, creator: int, destroyer: int, userdata: int) -> None: ...
    @overload
    def register_custom_layer(self, typeindex: int, creator: int, destroyer: int, userdata: int) -> None: ...
    def register_custom_layer(self, *args, **kwargs):
        """
        TODO: This API is C-style and likely unusable from Python.
        """
        ...

    def load_param(self, source: str | DataReader) -> None: ...
    def load_param_bin(self, source: str | DataReader | Any) -> None: ...
    def load_model(self, source: str | DataReader | Any) -> None: ...
    def clear(self) -> None: ...
    def get_input_name(self, i: int) -> str: ...
    def get_output_name(self, i: int) -> str: ...
    def get_input_index(self, i: int) -> int: ...
    def get_output_index(self, i: int) -> int: ...
    def create_extractor(self) -> 'Extractor': ...

class Extractor:
    def __del__(self) -> None: ...
    def set_option(self, opt: Option) -> None: ...
    def input(self, id: str | int, in_mat: Mat) -> int: ...
    def extract(self, id: str | int) -> Mat: ...
